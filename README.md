# chat_board
a chat board system

### 目录结构

+ config：存放配置文件（具体说明待扩充，下同）
+ model：model层，存放模型文件
+ template：view层，存放模板（视图）文件
+ view：controller层，存放路由文件及接口方法文件
+ util：存放工具类及常用工具方法
+ test：存放测试文件，包括单元测试及接口测试



# 系统漏洞描述

### 跨站脚本（XSS）

+ 漏洞成因：用户输入或一些用户可控参数未经处理地输出到页面上
+ 漏洞实现：在xss页面的搜索框中输入“<a href="https://www.baidu.com">百度</a> ”，下方本应出现简单的文本内容变为超链接，诱导正常用户点击进入到其他网站
+ 漏洞解决步骤：更改 xss.html 中修改页面标签元素的方法，改为flask中的{{参数}}方法，会将搜索框中输入的内容不转义而全部显示



### 跨站点请求伪造（CSRF）

+ 漏洞成因：用户信任网站a并登录，浏览器存在cookie时打开恶意网站b，b伪造用户向a发送请求
+ 漏洞实现：先在index页面登录账号，再到csrf页面下，点击“csrf漏洞”，转跳到 csrf_hack 页面，依靠浏览器已保存的cookie发送转账请求（项目处于csrf保护状态）
+ 漏洞产生步骤：注释掉app.py中的CsrfProtect(app)，并把index.html和csrf.html中的csrf_token语句删除即可（html中的语句仅注释会报错）



### HTTP 请求头注入





### 目标遍历漏洞





### SQL 注入
+ 漏洞成因：对用户输入数据的合法性没有判断或过滤不严，在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息
+ 漏洞实现：后端使用原生sql语句，在sql注入界面，当用户id输入为 '' or 1=1# 时会登录成功，因为#在mysql中也是注释符，输入之后就相当于
select * from login_url where id='' or 1=1
+ 漏洞解决步骤：flask-sqlalchemy自带ORM，可以防护SQL注入，使用其自带的查询语句即可



### 文件上传
+ 漏洞成因：上传文件的时，未对上传的文件进行严格的验证和过滤
+ 漏洞实现：后端未进行文件验证和过滤操作，可接受来自于前端的任意文件或脚本
+ 漏洞解决步骤：定义pdf文件的配置文件pdfconfig，对上传的文件惊醒验证过滤操作，限制其只能为pdf文件



### 文件下载
+ 漏洞成因：文件下载采用get方法传输数据，没有对下载的文件做限制，直接通过路径对文件进行下载，恶意用户就可以利用这种方式下载服务器的各种文件
+ 漏洞实现：前端传入的参数是文件的路径，在上方输入网址：http://127.0.0.1:5000/download?filepath=(本地文件路径)即可下载本地文件
+ 漏洞解决步骤：前端传入的数据仅仅为文件名，后端拼接可下载的pdf文件路径与文件名



### 日志不全

+ 漏洞成因：开发者没有在程序内引入/编写日志，对于某些系统异常或遭受到的攻击没有办法追踪定位，以至于无法解决。
+ 漏洞实现：不使用python内置库logging编写日志即可实现漏洞（其他第三方日志库同理），本程序内只要在入口文件`app.py`中将导入的日志配置类`logconfig`注释掉即可实现漏洞。
+ 漏洞解决步骤：对后端的每一个可调用方法的不同逻辑分支均编写相对应的日志，准确描述该操作的时间，操作的目标，操作的结果以及输出的内容，分层调用的方法则在每一层添加逻辑关系相连的日志，最终在日志文件中输出操作栈。



### 渗透测试漏洞