In the introduction, we talked about one of the memes across this video series being architecting for change. In this chapter, we're going to set the context for architecting for change and look at a couple of techniques we can do as architects to facilitate change within our architectures. So I've got three statements that we hear from the business. The first is this. Our business is constantly changing to meet the demands of the marketplace. You hear this from the business as well. We need faster time to market to remain competitive. And you'll also hear this from the business. Our plan is to engage heavily in mergers and acquisitions. Now I want to ask you, there's something common. There's a common theme about all of these statements. Does anybody know what it is? Change. Change. Exactly. Every single one of those statements-- mergers, time to market-- all have to do with change. Exactly. So change-- where? Change everywhere. And the problem is that the traditional methods of architecture are simply not sufficient enough to meet the demands of the ever-changing marketplace. A lot of stuff is changing. Business, for example, is in a constant state of change and has been, actually, for quite some time now. Increased competition, mergers, acquisitions, growth, regulatory changes, constant change within business. But that's not all, because for us, the technology is also in a constant state of change. New platforms, new languages, frameworks, patterns, products, constantly changing, upgrading. The two of those combined sets really the stage for change. So I wanted to define a term, architecture agility. And architecture agility really, as I'm defining it, is the ability architecturally to respond quickly to a constantly changing environment. So when you hear the word agility throughout the rest of this book series or architecture agility, this is exactly what we're talking about. How capable is the architecture of changing rapidly given changes in business and changes in technology? So there's a couple of techniques that we can apply architecturally to facilitate change or to create what I'll call agile architectures, because that's the name of the game for this meme right here, which is, change is happening. We cannot refute that. What can I do architecturally to make that change happen? What can I do to make my architectures much more agile? And I will put the caveat here, there are trade-offs in every one of these techniques. But what we're focusing on here is, how quickly can I respond to change in the architecture? So we're going to look at four main techniques very briefly in this chapter. The first is reduced dependencies technique. The next is leveraging standards. The third is create product agnostic architectures. And the fourth is creating domain-specific architectures. Let's take a little look at each of these pieces. Now the first one, reduce dependencies, the idea here as Neal had alluded to in the prior chapter on metrics and visualizations and kind of understanding large code bases, is that we have a lot of tooling available to understand dependencies and actually map those out visually. So we have four components here-- A, B, C, and D-- all talking to one another. The ability for any of those components to change is going to take a long time. The goal of reduced dependencies really is to move from this kind of topology to something that decouples. Whether it's messaging, whatever the mechanism, what we're trying to do here is to decouple those components. The idea is this. Component C right there needs to change. What's impacted generally throughout all of the left hand side of that architecture there, pretty much everything. If, however, component C over here changes, it's decoupled from the rest of the components, and I will put the caveat here, because I will absolutely be pragmatic. Contract changes usually require changes everywhere. If it's not a contract change, and actually I will put a caveat not everywhere, and we'll see in a later chapter in one of the patterns that we're going to be looking at in the next chapter where contract changes can also be isolated. But in general, contract changes are very pervasive. But the idea here is we're trying to isolate the component, and what do we buy from this? Well, there's less coordination required. Take a look at the left hand side. If I want to change component C-- this could be, by the way, something as small scoped as a Java class. It could also be a subsystem. It could be a JAR file. It could be a separate application portion that's done point to point. It doesn't matter on the scope. We're talking architecturally, so what I'd like to do is really draw that scope out to say, this is a broader scope. That's a subsystem. But it doesn't necessarily need to be. But the point here is if I want to change component C, and you're component A, and you're component B, and you're component C, the idea is I have to coordinate with you and say, hey, I'm changing this. Hey, you know what? My release schedule, we're going in next week. It's like, whoa, we don't have any resources to help you with that. Let's say component A, you don't have any resources for three weeks to actually work on adopting my change or even test it. So we've got a coordination issue. Now let's take a look at the right hand side over here. If I want to change component C, what coordination's needed? Not much. As a matter of fact, if it's not a contract change, you, you, you, you don't even need to know that I even changed anything. As a matter of fact, if the contract didn't change, you don't even have to test. I'm going to test, because you know why? The inputs and outputs are the same. I don't have to even involve you. So that's kind of the first key benefit of reducing the dependencies. There is faster time to deploy as well to the decoupling. On the left hand side over here, if I wanted to change component C, again, let's reduce the scale down. What else do I have to deploy? A, B, and C, because that also needs to possibly change. Over here on the right hand side, component C, what do I deploy? Component C. Again, this has a lot to do with release times and coordination of release cycles, but it also has to do with who needs to be notified that I'm changing anything. Kind of a third piece, and this is the one that I like the best-- components can actually evolve independently. Component C is very hard to evolve, and what I mean by evolve, let's say component C, whatever the scope, we're going to rewrite from scratch. Wow. Component A, B, and D right here are actually going to be a little scared about that. If I want to change component C from Java to C#, component A, B, and D, as long as I don't change the contract, doesn't even know. On the left hand side over here, everybody changes. The trade-off of reducing the dependencies, can you guess what the trade-off might be? Simplicity? Yes, simplicity. So a lot of cases, we are adding complexity when we try to reduce dependencies, because we're abstracting components out. Kind of building an extra component that's the go-between for all of the other-- We do need some sort of brokering or some sort of mechanism to create this abstraction. Yeah. The other thing I notice here is performance. Left hand side's point to point. Doesn't necessarily have to be, but it is. Usually dependent is, I guess, well, there's a lot of ways two components can be dependent, but what I'm referring to here is really a point to point connection versus abstracting it away asynchronously. So yeah, so we may lose some performance as well as this. Again, the trade-off of performance complexity versus the ability to change quickly. Think of that middle one, by the way. Time to market-- that's kind of an interesting one linking to change, because what that really refers to is if there's a time to market concern, that means we're releasing new features. We're releasing new features, because either we have to change to remain competitive, or the business is changing, and we have to add new regulations, new components, et cetera. Anyway, so we do have change, and how easy is it going to be to add new features, change features? Good. The implementation of this, by the way, as we talked about, we could do this in messaging. We could do this with a service bus. We could do this with adapters, or even as we're going to see in the next couple of chapters, even through architecture patterns. All four techniques you can use to reduce dependencies. Next one is leveraging standards. There's three types of standards that we have that we can actually leverage. I guess I would say three categorizations of standards. The first are industry standards, things like Swift, Fix, SOAP, XML, FpML, every industry has their own standards, whether it be for transport, whether it be for payload. These standards, whether they fit or not, allow us to integrate easier with external systems, with other systems. So the other is corporate standards. So corporate standards could overlap with industry standards, but they don't necessarily have to. So examples, you may be a .NET, C# client or company. You may be a J2EE. You may be a Rails shop. Eclipse is your standard development platform. The point here with the corporate standards, and this is probably, in some ways, more important than the industry standards, is the reason we get to leverage standards in terms of change is economies of scale, resource availability. So example, the company is a .NET shop, and I'm an architect, and I say, you know what? I'm tired of .NET. I want to use J2EE for this particular project. This architecture we're going to do as kind of a layered J2EE. What resources are there in the company? Very few. Or I want to introduce Rails, for example. How many resources do I have for Rails? Well, we have two developers. OK. So let's put them on this project. Guess what? That project now needs to change. How many Rails developers do I have? Two. And guess what? They're both busy. So again, agile architecture, architecture agility, the ability to respond quickly to a constantly changing environment. The fewer resources I have that don't adhere to these standards, the longer it's going to take and the harder it's going to take for change. There's a third type of standard as well, and that's de facto standards. These are standards that we all commonly know-- Hibernate, Spring, Struts, Tomcat. The resource pool of these are very large. They may not be the best fit for your architecture, but what we're talking about, again, is the ability to respond quickly to a changing environment. In my mind, that quick response is who could I get as fast as possible to change this? Fewer Google searches, let's say. So part of the point here is that all three of these, industry, whether it be corporate or de facto, as an architect, these standards may not be your first choice, but they do significantly reduce the effort for change. It has to do with the resource pool available. It's a larger resource pool, for example, for these. And this kind of points to that feasibility aspect as well. If we have a tight time frame and a tight budget, well, maybe we will use Struts. You know why? Because we already have frameworks in place. The other thing is it's better integration with other systems as well. One of the downsides of a larger resource pool is that you're going to get a much larger percentage of very average and below average developers in that larger pool, so if you're going for this strategy, you need to put more effort in good hiring to make sure that you get really good people out of that larger pool, because the larger pool is typically kind of shallow. So the third technique is product agnostic architecture, so the premise here basically is avoiding what's called vendor lock-in. This is actually an anti-pattern, which we'll be looking at in a couple of chapters. But the idea is to say this. You have a major vendor product here, and you have a lot of applications hooked directly off of it point to point. If you want to change that vendor product or that vendor product as an upgrade, what changes in your architecture? Well, pretty much everything. That change is going to take months. It could take years, so the idea here is to isolate the vendor. Take that major vendor product, and surround it with abstraction so that these applications are talking through various abstraction layers-- messaging, message bus, could be pattern-based, could be adapters, all four of those, and the idea is when this major vendor product changes, we're isolating the changes with all the applications. As a matter of fact, if we wanted to replace vendor product right there, how hard would that be on the left hand side? Extremely hard. If we look at the right hand side, well, it's a lot of effort, but at least it's feasible. And in fact, we talked a little bit about domain-driven design earlier. Domain-driven design has a fantastic term for this. It refers to these as anti-corruption layers, and I think that's a fantastic term, because it carries with it the connotation that that thing you're coupling to is going to corrupt you, so you need an anti-corruption layer to keep you from being too coupled to it. Yes, I like that. As a matter of fact, this anti-pattern, this is actually an anti-pattern on the left hand side, and it happens to be called the vendor king anti-pattern. And we will be looking at this in more detail in the first anti-patterns chapter. So the final technique is domain-specific architecture or domain-driven architecture. Either term works right here. But the idea here is that generic architecture is also called infinity architectures, because they can infinitely grow and support any kind of capability whatsoever. But they're difficult to change, because they're too broad, and they take into account scenarios that actually are not used. So for example, we have this huge long table, which is our architecture. Well, we may need to do this. Well, we don't know the requirements, so let's add this in. What it's doing is adding a lot of bulk and a lot of fluff to the architecture. When we need to go change it, we have to change those other pieces which we're not using as well. So there's a clear technique to actually do domain-specific architecture. We limit the scope of the architecture by taking into account the industry, the drivers, the business goals, the business direction, industry trends. There are certain industries that lead to certain domain-specific architectures. For example, most trading systems need high performance architectures. Most insurance systems need shared services, economies of scale with the services. So for example, to create a domain-specific architecture, we take into account things like business requirements. The business requirements will drive a portion of that architecture, where they take into account business goals. What are the goals of the business? What is it trying to achieve? Are we trying to do mergers and acquisitions in the next three to five years? That's going to form a portion of the architecture here. Then we take into account the business direction, which is somewhat different than the goals. The goal may be to be the number one retail insurance company in the world, yet the direction is it's losing money hand over fist every month. It's going to be really hard to achieve the goals. The direction is not going well, so I'm going to watch the spending on this. That forms a proportion of that architecture. And finally, the industry trends, so all four of these together is actually the technique of how you build a domain-specific architecture. That coupled with the generalization of certain industries lead to certain different patterns. All right. Are there any questions? No? Good. OK. So in the next chapter, we'll be starting to talk about various architecture patterns. Thank you. 